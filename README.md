# Proyecto-EPM
Ingresaremos la RNN para predecir ENSA
# -*- coding: utf-8 -*-
"""Datos_Maestro_EPM_Brayan_Jhonatan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lqReuL4pH_99e52RNZ7R4py6QvtBrTm5

# ANALITICA DE DATOS CON INTELIGENCIA ARTIFICIAL

# EDA con datos EPM

**Universidad de los Andes**

2024

---

Juan C. Vega MsC
"""

from google.colab import drive
drive.mount('/content/drive')

"""# PREDICCION DE ENSA A PARTIR DE DEEP LEARNING para EL MES DE MAYO

**Necesidad:** modelar la relación existente entre el registro de temperatura de las instalaciones (puntos de servicio) del Área Metropolitana de Medellín de acuerdo con tomas de drones termográficos (por realizar) y el consumo de energía de las instalaciones, así como el registro histórico de defraudaciones de dicho servicio (fraudes).
"""

# Importar las bibliotecas necesarias
import pandas as pd
import numpy as np
from sklearn.model_selection import TimeSeriesSplit
from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, InputLayer
from matplotlib import pyplot as plt
import seaborn as sns

# Montar Google Drive (asumiendo que los datos están allí)
from google.colab import drive
drive.mount('/content/drive')

# Cargar los datos
file_path = '/content/drive/MyDrive/BD_maestro.csv'  # Ajusta a la ubicación de tu archivo CSV
datos_Maestro = pd.read_csv(file_path)

# Convertir la columna 'fecha' a datetime
datos_Maestro['fecha'] = pd.to_datetime(datos_Maestro['fecha'])

datos_Maestro.describe()

# Encontrar NaNs y valores duplicados en datos_Maestro

print('hay {} valores missing o NaNs en datos_Maestro.'
      .format(datos_Maestro.isnull().values.sum()))

temp_datos = datos_Maestro.duplicated(keep='first').sum()

print('hay {} filas duplicadas en datos_Maestro revisando todas las columnas.'
      .format(temp_datos))

# EDA básico: matriz de correlación y gráficas
sns.heatmap(datos_Maestro.corr(), annot=True, cmap='cividis')
plt.show()

correlations = datos_Maestro.corr(method='pearson')
print(correlations['ENSA'].sort_values(ascending=False).to_string())

# Se excluye 'fecha' por ser una variable temporal y 'dummy' por tener NaNs
columns_to_plot = ['ENSA', 'Panama', 'PIB__corriente', 'PIB_real', 'oni']

# Crear gráficos de distribución para cada una de las variables seleccionadas
for col in columns_to_plot:
    sns.displot(datos_Maestro[col], kde=True)
    plt.title(f'Distribución de {col}')
    plt.xlabel(col)
    plt.ylabel('Densidad')
    plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Asegúrate de tener 'datos_Maestro' como tu DataFrame y que 'ENSA' sea una de las columnas.
columnas = ['oni', 'PIB_real', 'PIB_(%)_real', 'PIB__corriente', 'PIB_(%)_corriente',
            'wti_usd_barril', 'hh_usd_mllbtu', 'Panama']  # Coloca aquí todas las columnas excepto 'ENSA'

for columna in columnas:
    plt.figure(figsize=(8, 4))  # Configura el tamaño del gráfico
    sns.histplot(datos_Maestro[columna], kde=True)  # Histograma con KDE
    plt.title(f'Distribución de {columna} respecto a ENSA')  # Añade un título al gráfico
    plt.xlabel(columna)  # Etiqueta del eje x
    plt.ylabel('Frecuencia')  # Etiqueta del eje y
    plt.show()  # Muestra el gráfico

# Calcular el promedio móvil de la serie ENSA con una ventana de 3 meses.
# El '3' es un número arbitrario y debería ser ajustado basado en el conocimiento del dominio.
datos_Maestro['ENSA_PROMEDIO_MOVIL'] = datos_Maestro['ENSA'].rolling(window=3).mean()

# Manejar valores NaN que se crean por el cálculo del promedio móvil en las primeras filas
datos_Maestro['ENSA_PROMEDIO_MOVIL'] = datos_Maestro['ENSA_PROMEDIO_MOVIL'].fillna(method='bfill')
#Este promedio móvil puede ayudar al modelo LSTM a entender mejor las tendencias subyacentes en los datos de ENSA, además de las variaciones a corto plazo que ya captura el modelo.

datos_Maestro.dtypes

'''ax = plot_series(df=datos_Maestro, column='ENSA', ylabel='ENSA(xxx)',
                 title='ENSA actual ')
plt.show()'''

# Definir una función para graficar series temporales
def plot_series(df=None, column=None, series=pd.Series([]),
                label=None, ylabel=None, title=None, start=0, end=None):
    # Configura el estilo visual de los gráficos de Seaborn
    sns.set()
    # Crea una figura y un solo subplot con tamaño específico
    fig, ax = plt.subplots(figsize=(30, 12))
    # Establece la etiqueta del eje x
    ax.set_xlabel('Time', fontsize=16)
    # Si se proporcionó una columna, grafica la columna del DataFrame
    if column:
        ax.plot(df[column][start:end], label=label)
        ax.set_ylabel(ylabel, fontsize=16)
    # Si se proporcionó una serie, grafica la serie
    if series.any():
        ax.plot(series[start:end], label=label)
        ax.set_ylabel(ylabel, fontsize=16)
    # Si se proporcionó una etiqueta, añade una leyenda
    if label:
        ax.legend(fontsize=16)
    # Si se proporcionó un título, establece el título del gráfico
    if title:
        ax.set_title(title, fontsize=24)
    # Añade una cuadrícula al gráfico para facilitar la lectura
    ax.grid(True)
    # Devuelve el objeto ax con el gráfico
    return ax

# Ejemplo de uso de la función para graficar los primeros dos años de la columna 'ENSA'
ax = plot_series(df=datos_Maestro, column='ENSA', ylabel='ENSA',
                 title='ENSA actual (Primeros 2 años)', end=24)
plt.show()

# Borrar columnas con informacion metereologica cualitativa
datos_Maestro = datos_Maestro.drop(['dummy'], axis=1)

datos_Maestro.info()

# Estandarización de los datos  prueba
scaler = StandardScaler()
datos_numericos = datos_Maestro.select_dtypes(include=[np.number])
datos_escalados = scaler.fit_transform(datos_numericos)
datos_escalados = pd.DataFrame(datos_escalados, columns=datos_numericos.columns)

# Añadir de nuevo las columnas no numéricas al DataFrame escalado
for col in datos_Maestro.select_dtypes(exclude=[np.number]).columns:
    datos_escalados[col] = datos_Maestro[col]

# Estandarización de los datos

# Seleccionar solo columnas numéricas
datos_numericos = datos_Maestro.select_dtypes(include=[np.number])

# Estandarización de los datos numéricos
scaler = StandardScaler()
datos_escalados = scaler.fit_transform(datos_numericos)
datos_escalados = pd.DataFrame(datos_escalados, columns=datos_numericos.columns)

# Añadir de nuevo las columnas no numéricas al DataFrame escalado
for col in datos_Maestro.select_dtypes(exclude=[np.number]).columns:
    datos_escalados[col] = datos_Maestro[col]

datos_numericos.info()

# Preparar datos para LSTM
window_size = 24
X = []
y = []

for i in range(window_size, len(datos_numericos) - 12):  # -12 para predecir el año completo de 2024
    X.append(datos_numericos.iloc[i-window_size:i, :-1].values)  # Todas las variables excepto ENSA
    y.append(datos_numericos['ENSA'].iloc[i])  # La variable ENSA

X, y = np.array(X), np.array(y)

# División en entrenamiento y validación
train_size = int(len(X) * 0.8)
X_train, X_val = X[:train_size], X[train_size:]
y_train, y_val = y[:train_size], y[train_size:]

# Definir la arquitectura LSTM
model = Sequential([
    InputLayer((window_size, datos_numericos.shape[1] - 1)),
    LSTM(131, activation='relu'),
    Dense(151, activation='tanh'),
    Dense(1, activation='linear')
])

# Definir la arquitectura GRU
#model = Sequential([
    #InputLayer(input_shape=(window_size, datos_numericos.shape[1] - 1)),
    #GRU(50, activation='relu', return_sequences=True),
    #GRU(50, activation='relu'),
    #Dense(20, activation='relu'),
    #Dense(1)
#])

# Compilar y entrenar el modelo
model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(X_train, y_train, epochs=100, batch_size=32, validation_data=(X_val, y_val))

# Generar predicciones para 2024 (esto requiere datos futuros que podríamos simular o extender en base a los últimos datos disponibles)

"""# **Pasos a seguir**

**Generación de características futuras:** como el modelo depende de entradas que necesitamos prever (como las temperaturas futuras), necesitamos estimar o simular estos datos para 2024.

**Extensión del conjunto de datos:** Extendiendo los datos hasta junio de 2024, asumiendo ciertas tendencias o repitiendo patrones anteriores si no hay mejor estimación disponible.

**Predicción con el modelo:** Utilizar el modelo para hacer las predicciones basadas en estas entradas extendidas o simuladas.
"""

import numpy as np
import pandas as pd
from datetime import timedelta
import matplotlib.pyplot as plt

# Simular datos futuros para las características necesarias basándonos en las últimas observaciones
last_date = datos_Maestro['fecha'].max()
future_dates = pd.date_range(start=last_date + timedelta(days=1), periods=6, freq='M')
# Mostrar las predicciones
print(future_dates)

# Asumiendo que la tendencia de las características numéricas se mantiene constante
future_data = []
for date in future_dates:
    last_row = datos_numericos.iloc[-1].copy()
    last_row.name = date
    future_data.append(last_row)

future_df = pd.DataFrame(future_data)

# Concatenar los datos simulados con los datos originales
extended_data = pd.concat([datos_numericos, future_df])

# Escalar los datos extendidos
extended_scaled = scaler.transform(extended_data)
extended_scaled = pd.DataFrame(extended_scaled, columns=datos_numericos.columns)

# Preparar datos para LSTM incluyendo los futuros
X_extended = []
y_extended = []

for i in range(window_size, len(extended_scaled) - 6):  # Preparar hasta junio de 2024
    X_extended.append(extended_scaled.iloc[i-window_size:i, :-1].values)  # Excluir ENSA
    y_extended.append(extended_scaled.iloc[i, -1])  # Incluir ENSA

X_extended = np.array(X_extended)
y_extended = np.array(y_extended)

# Predicciones para los primeros 6 meses de 2024
predictions = model.predict(X_extended[-6:])  # Últimos 6 registros para predicción

num_features = datos_numericos.shape[1] - 1  # Número de características sin contar ENSA
predictions_scaled = np.zeros((predictions.shape[0], num_features + 1))
predictions_scaled[:, -1] = predictions.flatten()  # Inserta las predicciones en la última columna

# Desescalar las predicciones
predictions_descaled = scaler.inverse_transform(predictions_scaled)[:, -1]

# Mostrar las predicciones desescaladas
print("Predicciones de ENSA desescaladas para los primeros 6 meses de 2024:")
print(predictions_descaled)

# Crear un DataFrame para las predicciones desescaladas
predictions_df = pd.DataFrame({
    'fecha': future_dates,
    'ENSA_pred': predictions_descaled  # Usar predicciones desescaladas
})

# Combinar los datos históricos con las predicciones
combined_data = pd.concat([historical_data.set_index('fecha'), predictions_df.set_index('fecha')], axis=1)

# Graficar los resultados
plt.figure(figsize=(15, 7))
plt.plot(combined_data.index, combined_data['ENSA'], label='Historical ENSA', color='blue')
plt.plot(combined_data.index, combined_data['ENSA_pred'], label='Predicted ENSA', color='red', linestyle='--')
plt.title('Historico y Prediccion ENSA desde 2022 a 2024')
plt.xlabel('Date')
plt.ylabel('ENSA')
plt.legend()
plt.grid(True)
plt.show()

# Mostrar las predicciones
print("Predicciones de ENSA para los primeros 6 meses de 2024:")
print(predictions.flatten())

"""**Supongamos que 'predictions' es el array obtenido de las predicciones anteriores**
**y 'future_dates' contiene las fechas correspondientes a estas predicciones**
"""

# Crear un DataFrame para las predicciones
predictions_df = pd.DataFrame({
    'fecha': future_dates,
    'ENSA_pred': predictions.flatten()
})

# Filtrar los datos desde 2022 para visualizar
historical_data = datos_Maestro[(datos_Maestro['fecha'] >= '2022-01-01') & (datos_Maestro['fecha'] <= last_date)]
historical_data = historical_data[['fecha', 'ENSA']]

# Combinar los datos históricos con las predicciones
combined_data = pd.concat([historical_data, predictions_df])

# Graficar los resultados
plt.figure(figsize=(15, 7))
plt.plot(combined_data['fecha'], combined_data['ENSA'], label='Historical ENSA', color='blue')
plt.plot(combined_data['fecha'], combined_data['ENSA_pred'], label='Predicted ENSA', color='red', linestyle='--')
plt.title('Historico y Prediccion ENSA desde 2022 a 2024')
plt.xlabel('Date')
plt.ylabel('ENSA')
plt.legend()
plt.grid(True)
plt.show()
